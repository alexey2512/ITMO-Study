Все домашние задания мы пишем на Scala 3, но не продвигаем решение писать optional braces, если вы хотите, можете
настроить scalafmt под себя.

**UPDATE**: в этом домашнем задании мы в качестве эксперимента поставили Scala 2.13, так как многие жаловались на
проблемы с IDE. Если вы хотите писать на Scala 3, welcome!

# ADT и здание

1. Отразить в ADT следующую предметную область:
    1. Здание `Building`. У здания есть строковый адрес `address` и этажи `Floor` (ссылка на 1-й этаж)
    2. Этаж бывает жилым `ResidentialFloor`, чердаком `Attic` или коммерческим `CommercialFloor`
    3. У каждого жилого этажа `ResidentialFloor` есть 2 постояльца `Resident` и лестница на следующий этаж `Floor` (
       просто ссылка на этаж)
    4. У каждого коммерческого этажа `CommercialFloor` есть несколько заведений `Commercial` (минимум 1) и лестница на
       следующий этаж `Floor` (да, в этом доме можно открыть свою кальянную на 5 этаже, 
       даже если всего этажей 10 :kekw:)
    5. Чердак `Attic` может быть обычным `CommonAttic`, либо тоже коммерческим `CommercialAttic`, но только с 1
       заведением `Commercial`.
    6. У постояльца `Resident` есть возраст `age` (>0) и пол `Sex` (м/ж).
    7. Нумерация этажей идет с единицы.
    8. Если хотите, можете в произвольном порядке поменять изначальные сигнатуры, которые уже написаны у `Building` и
       `Floor`.
2. При создании здания `Building` необходимо убедиться, что все входные данные не нарушают логику обозначенной модели.
   Иначе, возвращать соответствующий тип ошибки (на разные невалидные параметры разный тип ошибки). Использование
   `assert`, `require` и `throw` запрещено.
3. Реализовать функцию `fold` аккумулирующую целое число во время обхода здания. На каждом этаже аккумулируемое значение
   пересчитывается с помощью функции `f`, параметрами которой служат текущее значение аккумулятора и этаж (Первый
   параметр, это текущий аккумулятор. Второй, текущий этаж) Здание обходить снизу вверх.
   Аккумулятор изначально равен `accumulator`.
4. `countOldManFloors` - Используя функцию `fold` посчитать количество этажей, где есть хотя бы один мужчина старше
   `olderThan` (если нет, то 0)
5. `womanMaxAge` - Используя функцию `fold` посчитать максимальный возраст женщины в здании, если нет женщин, то `None`
6. `countCommercial` - Используя функцию `fold` посчитать кол-во коммерческих заведений в здании (если нет, то 0)
7. `countCommercialAvg` - Используя свою собственную функцию, похожую на `fold`, посчитать среднее кол-во коммерческих
   заведений в зданиях (если нет, то 0). Если знаете, как работать с тайп параметрами в функциях, то можно изменить
   сигнатуру самой функции `fold`, и использовать ее.
8. `evenFloorsMenAvg` - Используя свою собственную функцию, похожую на `fold`, посчитать среднее кол-во мужчин на четных
   этажах (если нет, то 0)
9. Напишите тесты в `BuildingSpec.scala`. На функцию fold отдельные тесты писать не обязательно

### Code Style:

Мы последовательно вводим список запрещенных механик, которыми нельзя пользоваться при написании кода, и рекомендаций по
code style. За нарушения мы оставляем за собой право **снижать оценку**.

* Переменные и функции должны иметь осмысленные названия;
* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс `Fibonacci` находится в
  пакете `fibonacci` в директории `src/main/scala/fibonacci`, значит его тест класс `FibonacciSpec` должен быть в том же
  пакете в директории `src/test/scala/fibonacci`);
* Использовать `var` запрещается;
* Использование `return` запрещается;
* Использование `System.exit` запрещается;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`);
* Каст типов с помощью `asInstanceOf`, проверка типов через `isInstanceOf` запрещены. Обратите внимание, что в одном из
  следующих домашних заданий мы можем разрешить ими воспользоваться;
* Использование не безопасных вызовов разрешено только в тестах (например `.get` у `Option`);
* Запрещено кидать ошибки через `throw`. Для моделирования кода, который может бросить ошибку разрешено использовать
  только `Option`, `Either`, `Try`;
* Пайплайны в Merge Request обязательно должны проходить и быть зелеными, и при этом должны запускаться scalafmt и
  тесты;
* Правки в условиях запрещены. Разрешено делать это только отдельным MR в `upstream`, где вы можете указать нам на
  недочет в условии задания;
