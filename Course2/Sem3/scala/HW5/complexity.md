### solve1
В первом решении производится слайдинг по списку с длиной подсписка k за O(n), 
на каждой итерации слайдинга вычисляется максимум на подсписке за O(k).
Далее за O(n) методами map и toList результат преобразуется в ответ,
при этом используется O(n) дополнительной памяти. Таким образом время - O(nk),
доп. память - O(n).
### solve2
Здесь используется алгоритм поиска максимума в бегущем окне через два стека.
Проходимся по всему списку и поддерживаем ```front-stack```, в котором храним постфиксные
максимумы на соответствующем подсписке, и ```back-stack```, в котором храним префиксные максимумы
на соответствующем подсписке, так что суммарный размер обоих стеков инвариантно равен k. 
На каждой итерации находим максимум из вершин обоих стеков и для следующей итерации попаем
из ```front-stack``` и пушим в ```back-stack``` максимум из вершины стека и следующего значения в 
исходном списке. Таким образом корректно вычисляем максимум в текущем окне.
Когда ```front-stack``` оказывается пуст, производим перезаполнение постфиксных минимумов за O(k) 
(функция ```fillPostfixmaxes```). 
Заметим, что перезаполнение производится каждые k итераций единожды, то есть в итоге получаем временную
сложность O(n) и O(k) дополнительной памяти. В моей же реализации при проходе по списку функцией 
```fold``` back-stack не поддерживается, а вместо него поддерживается максимум ```backMax``` из соответствующего
ему подсписка. Это позволяет уменьшить объем дополнительной памяти во время выполнения.
